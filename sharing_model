
# coding: utf-8

from pulp import *
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sn
from sklearn.preprocessing import StandardScaler

# return
# sites, including org and des
# distance matrix,
# locations of each sites
def generate_sites(num_customer_sites):
    # create sites
    # sites = ['org','A','B','C','D','E','des']
    sites = list(np.arange(0, num_customer_sites + 3))
    sdtlist = []

    # create distance matrix
    d_matrix = np.zeros((len(sites), len(sites)))

    # random generate points
    # np.random.seed(123)
    positions = dict((a, (np.random.rand() - .5, np.random.rand() - .5)) for a in sites)
    # org
    positions[0] = (0, 0)
    # pick up nodes
    positions[1] = (-0.2, -0.05)
    positions[2] = (-0.25, 0.15)
    # positions[3] = (-0.4, -0.05)
    positions[3] = (0.3, 0.25)
    positions[4] = (-0.05, 0.3)
    positions[5] = (-0.25,-0.15)
    positions[6] = (0.25, 0.45)
    positions[7] = (0.45, 0.1)
    # positions[9] = (0.35, 0.25)
    # positions[10] = (0.45, 0.18)
    # det
    positions[8] = (-0.2, 0.3)
    positions[9] = (0.3, 0.3)

    # plot it
    for s in positions:
        p = positions[s]
        plt.plot(p[0], p[1], 'o')
        plt.text(p[0] + .01, p[1], s, horizontalalignment='left', verticalalignment='center')
    plt.gca().axis('off');
    plt.show()

    # a function for computing distance between two points
    d = lambda p1, p2: np.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

    # calculate all the pairs
    for idx1, s1 in enumerate(positions):
        for idx2, s2 in enumerate(positions):
            if s1 != s2:
                d_matrix[idx1, idx2] = d(positions[s1], positions[s2])
    # print(d_matrix)

    for i in range(0,len(sites)):
        sdtlist.append(d(positions[i], positions[1]))
    return sites,d_matrix,positions,sdtlist

def visualize_result(non_zero_edges,sites,positions):
    # In[488]:

    def get_next_site(parent):
        '''helper function to get the next edge'''
        edges = [e for e in non_zero_edges if e[0]== parent]
        # print (edges)
        for e in edges:
            non_zero_edges.remove(e)
        return edges

    tours = get_next_site(0)
    # print (tours)
    tours = [ [e] for e in tours ]
    n = 1
    for t in tours:
        while n < len(sites)-1:
            if t[-1][1] != 0:
                # print (t[-1][1])
                t.append(get_next_site(t[-1][1])[-1])
                n +=1

    # The optimal tours:
    for t in tours:
        print(' -> '.join([ str(a) for a,b in t]+['9']))

    #draw the tours
    colors = [np.random.rand(3) for i in range(len(tours))]
    for t,c in zip(tours,colors):
        for a,b in t:
            p1,p2 = positions[a], positions[b]
            plt.plot([p1[0],p2[0]],[p1[1],p2[1]], color=c)

    #draw the map again
    for s in positions:
        p = positions[s]
        plt.plot(p[0],p[1],'o')
        plt.text(p[0]+.01,p[1],s,horizontalalignment='left',verticalalignment='center')

    plt.gca().axis('off');
    plt.show()

def main():


    num_customer_sites = 7
    K = 1  # the number of sales people(cars)
    staytime = 1
    M = 9999

    # geneate sites
    sites, d_matrix, positions,sdtlist= generate_sites(num_customer_sites)
    avg_d_matrix = d_matrix.mean()
    std_d_matrix = d_matrix.std()
    print(avg_d_matrix,std_d_matrix)
    standardized_d_matrix = StandardScaler().fit_transform(d_matrix)

    #generate indices for distance matrix
    X,Y = np.meshgrid( np.arange(len(sites)), np.arange(len(sites)) )
    matrix_coordinate_list = []
    for coor in zip(X.flatten(),Y.flatten()):
        matrix_coordinate_list.append(coor)

    t_matrix = d_matrix/0.05
    avg_t_matrix = t_matrix.mean()
    std_t_matrix = t_matrix.std()
    print(avg_t_matrix,std_t_matrix)
    standardized_t_matrix = StandardScaler().fit_transform(t_matrix)

    # all feasible solution

    #create the problme
    prob=LpProblem("transpotation",LpMinimize)

    # indicator variable if site i is connected to site j in the tour
    x = LpVariable.dicts('x', (sites,sites), 0, 1, LpBinary)
    #dummy vars to eliminate subtours
    z = LpVariable.dicts('z', sites, 0, num_customer_sites, LpInteger)

    s = LpVariable.dicts('s', sites, 0, None , LpContinuous)
    # for i in range(len(sites)):
    #     if i == 1:
    #         s[i] = 100
    #     else:
    #         s[i] = 0
    # s[0]=0
    u = LpVariable('u', LpContinuous)

    dist = sum([x[r][c] * standardized_d_matrix[r, c] for (r, c) in matrix_coordinate_list])
    # stddist = (dist - avg_d_matrix)/std_d_matrix
    print(type(dist))
    avgtime1 =  sum([s[8] - s[i] for i in range(1,len(s)-5)])
    avgtime2 = sum([s[9] - s[i] for i in range(5,len(s)-2)])
    avgtime = (avgtime1 + avgtime2)/num_customer_sites

    # the objective
    alpha = 0.5
    beta = 0.5
    gamma = 0
    cost = lpSum(alpha * dist + beta * avgtime + gamma * u)
    prob+=cost

    #add constraints
    # (1) the diagonal value of x matrix is 0
    prob += lpSum([ x[r][c] for (r,c) in matrix_coordinate_list if r==c ]) == 0

    # (2) org, node 1 - 5 can not go to des2
    for (r, c) in matrix_coordinate_list:
        if c == 9 and (r == 0 or r == 1 or r == 2 or r == 3 or r == 4):
            prob += (lpSum([x[r][c]]) == 0)
    # (3) org can not go to des1
    prob += lpSum([x[r][c] for (r, c) in matrix_coordinate_list if r == 0 and c == 8]) == 0
    # (4) des1 can not go to node 1 to node 5
    for (r, c) in matrix_coordinate_list:
        if r == 8 and( c == 1 or c == 2 or c == 3 or c == 4 ):
            prob += (lpSum([x[r][c]]) == 0)
    # (5) des2 is the finial visited node
    prob += lpSum([x[r][c] for (r, c) in matrix_coordinate_list if r == 9]) == 0
    # (6) no node can go to org
    prob += lpSum([x[r][c] for (r, c) in matrix_coordinate_list if c == 0]) == 0
    # (7) each node is visted only once
    for i in range(0, len(sites)-1):
        prob += lpSum([ x[r][c] for (r,c) in matrix_coordinate_list if r== i ]) == 1
    # (8) each node is visited only once
    for i in range(1, len(sites)):
        prob += lpSum([ x[r][c] for (r,c) in matrix_coordinate_list if c== i ]) == 1
    # (9) no circular route
    prob += (lpSum([x[r][c] + x[c][r] for (r,c) in matrix_coordinate_list if r == c])) <= 1
    # subtour elimination
    N=len(sites)/K
    for i in sites:
        for j in sites:
            if i != j and (i != 0 and j!= 0 and i != 1 and j!= 1) and (i,j) in matrix_coordinate_list:
                prob += z[i] - z[j] <= (N)*(1-x[i][j]) - 2

    # (9) start time is set correctly along the path
    for (r, c) in matrix_coordinate_list:
        prob += s[c] - s[r] - standardized_t_matrix[r,c] + M*(1 - x[r][c])>= staytime
    # pick up all the passengers to des1 before arriving des1
    for i in range(1, len(sites)-5):
        prob += s[len(sites)-2] - s[i] >= 0
    # node 9 is the last visited node
    for i in range(0, len(sites)):
        prob += s[len(sites)-1] - s[i] >= 0
    # The problem data is written to an .lp file
    # prob.writeLP("my_problem.lp")
    result = prob.solve()
    print(LpStatus[prob.status])

    # print solution
    print(value(prob.objective))
    for v in prob.variables():
        print(v.name, "=", v.varValue)

    non_zero_edges = [ e for e in matrix_coordinate_list if value(x[e[0]][e[1]]) != 0 ]
    print (non_zero_edges)

    totaldist = []
    totaltime = []
    for a, b in non_zero_edges:
        totaldist.append(d_matrix[a, b])
        totaltime.append(t_matrix[a,b])
    # print(totaldist)
    # print(totaltime)
    starttime = []
    for i in range(0,len(totaltime)):
        s[len(totaltime)-i] = sum(totaltime[i:len(totaltime)])
    print("The start time at each node is: ")
    print(s)
    print("The optimal distance is: ", sum(totaldist))
    print("The optimal time is: ", sum(totaltime))
    # see the result
    visualize_result(non_zero_edges, sites, positions)


if __name__ == '__main__':
    main()